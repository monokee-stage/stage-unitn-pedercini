import * as jose from 'jose';
import { GeneralDailyRotateFileTransportOptions } from 'winston-daily-rotate-file';

declare type AuthenticationRequest = {
    /** authentication reqest unique identifier (generated radnomly by relying party) */
    state: string;
    /** generated randomly by relying party */
    code_verifier: string;
    /** got from relying party configuration */
    redirect_uri: string;
    /** got from provider configuration */
    token_endpoint: string;
    /** got from provider configuration */
    userinfo_endpoint: string;
    /** got from provider configuration */
    revocation_endpoint: string;
    /** got from provider configuration */
    provider_jwks: JWKs;
};

declare type UserInfo = UserInfoSPID | UserInfoCIE;
declare type UserInfoSPID = {
    "https://attributes.spid.gov.it/name"?: string;
    "https://attributes.spid.gov.it/familyName"?: string;
    "https://attributes.spid.gov.it/placeOfBirth"?: string;
    "https://attributes.spid.gov.it/countyOfBirth"?: string;
    "https://attributes.spid.gov.it/dateOfBirth"?: string;
    "https://attributes.spid.gov.it/gender"?: string;
    "https://attributes.spid.gov.it/companyName"?: string;
    "https://attributes.spid.gov.it/registeredOffice"?: string;
    "https://attributes.spid.gov.it/fiscalNumber"?: string;
    "https://attributes.spid.gov.it/ivaCode"?: string;
    "https://attributes.spid.gov.it/idCard"?: string;
    "https://attributes.spid.gov.it/mobilePhone"?: string;
    "https://attributes.spid.gov.it/email"?: string;
    "https://attributes.spid.gov.it/address"?: string;
    "https://attributes.spid.gov.it/expirationDate"?: string;
    "https://attributes.spid.gov.it/digitalAddress"?: string;
};
declare type UserInfoCIE = {
    sub?: string;
    given_name?: string;
    family_name?: string;
    email?: string;
    email_verified?: string;
    gender?: string;
    birthdate?: string;
    phone_number?: string;
    phone_number_verified?: string;
    address?: string;
    place_of_birth?: string;
    document_details?: string;
    e_delivery_service?: string;
    fiscal_number?: string;
    physical_phone_number?: string;
};

/**
 * This configuration must be done on the relying party side
 *
 * see field descriptions to understand how to customize relying party
 */
declare type Configuration = {
    /**
     * Url that identifies this relying party.
     * The relying party must be reachable on this url from outside
     */
    client_id: string;
    /**
     * Human-readable name of this application
     */
    client_name: string;
    /**
     * urls that identifies trust anchors
     *
     * @example ["https://registry.spid.gov.it/"]
     */
    trust_anchors: Array<string>;
    /**
     * OPTIONAL. JSON array with one or more strings representing contact persons at the entity.
     * These MAY contain names, e-mail addresses, descriptions, phone numbers, etc.
     *
     * See the [relevant specification for OpenID](https://openid.net/specs/openid-connect-federation-1_0.html#rfc.section.4.6).
     */
    contacts?: Array<string>;
    /**
     * urls that identifies identity providers
     * @example {
     *  spid: ["https://spid.ag-pub-full.it/"],
     *  cie: ["https://cie.agid.gov.it/"]
     * }
     */
    identity_providers: Record<IdentityProviderProfile, Array<string>>;
    /**
     * list of urls where the user browser will be redirected
     *
     * At least one redirect uri is required.
     *
     * The first redirect uri will be used for callback enpoint in this implementation
     *
     * @example ["https://my.domain/callback"]
     */
    redirect_uris: Array<string>;
    /**
     * you obtain these during onboarding process, they are needed for security purposes
     *
     * load them from filesystem or database
     */
    trust_marks: Array<TrustMark>;
    /**
     * jwks format of your public keys
     *
     * load them from filesystem or database (do not commit your cryprographic keys)
     *
     * these keys are needed during onboarding process wiht federation and for comunication with provider
     *
     * you can generate them with {@link generateJWKS}
     */
    public_jwks: JWKs;
    /** @see {@link Configuration.public_jwks} */
    private_jwks: JWKs;
    application_type: "web";
    response_types: Array<"code">;
    scope: Array<"openid" | "offline_access">;
    token_endpoint_auth_method: Array<"private_key_jwt">;
    providers: {
        [P in IdentityProviderProfile]: {
            /** what level of authentication is required */
            acr_values: AcrValue;
            /** what information to request about user from provider */
            requestedClaims: {
                id_token: Partial<Record<IdentityProviderProfileClaims[P], {
                    essential: true;
                }>>;
                userinfo: Partial<Record<IdentityProviderProfileClaims[P], null>>;
            };
        };
    };
    /** jwt default expiration in seconds */
    federation_default_exp: number;
    /** supply a storage that will be used to store intermediate stateful data  */
    storage: AsyncStorage<AuthenticationRequest>;
    /**
     * a function that will be called to log detailed events and exceptions
     * @see {@link logRotatingFilesystem} for an example
     */
    logger: AbstractLogging;
    /**
     * a function that will be called to log mandatory details that must be stored for 24 months (such as access_token, refresh_token, id_token)
     * @see {@link auditLogRotatingFilesystem} for an example
     */
    auditLogger(message: object | unknown): void;
    httpClient: HttpClient;
};
declare type TrustMark = {
    id: string;
    trust_mark: string;
};
declare type JWKs = {
    keys: Array<jose.JWK>;
};
declare type IdentityProviderProfile = "spid" | "cie";
declare type IdentityProviderProfileClaims = {
    spid: keyof UserInfoSPID;
    cie: keyof UserInfoCIE;
};
/** level of authentication */
declare type AcrValue = typeof AcrValue[keyof typeof AcrValue];
/** level of authentication */
declare const AcrValue: {
    readonly l1: "https://www.spid.gov.it/SpidL1";
    readonly l2: "https://www.spid.gov.it/SpidL2";
    readonly l3: "https://www.spid.gov.it/SpidL3";
};
declare type HttpRequest = {
    method: "GET";
    url: string;
    headers?: Record<string, string | undefined>;
} | {
    method: "POST";
    url: string;
    headers?: Record<string, string | undefined>;
    body: string;
};
declare type HttpResponse = {
    status: number;
    headers: Record<string, string | undefined>;
    body: string;
};
declare type HttpClient = (request: HttpRequest) => Promise<HttpResponse>;
declare type AsyncStorage<T> = {
    read(rowId: string): Promise<T>;
    write(rowId: string, value: T): Promise<void>;
    delete(rowId: string): Promise<void>;
};
declare type LogLevels = "fatal" | "error" | "warn" | "info" | "debug" | "trace";
declare type AbstractLogging = {
    [K in LogLevels]: (...args: any[]) => void;
};
declare type MandatoryConfiguration = Pick<Configuration, "client_id" | "client_name" | "trust_anchors" | "identity_providers" | "logger" | "auditLogger" | "storage">;
declare type AdditionalConfiguration = {
    /**
     * The path (relative to the CWD) where to find the Public JWKs, if not passed
     * directly as `public_jwks`.
     */
    public_jwks_path?: string;
    /**
     * The path (relative to the CWD) where to find the Private JWKs, if not passed
     * directly as `private_jwks`.
     */
    private_jwks_path?: string;
    /**
     * The path (relative to the CWD) where to find the Trust Marks, if not passed
     * directly as `trust_marks`.
     */
    trust_marks_path?: string;
};
declare type ConfigurationFacadeOptions = MandatoryConfiguration & Partial<Configuration> & AdditionalConfiguration;

declare type Tokens = Readonly<{
    id_token: string;
    access_token: string;
    refresh_token?: string;
    revocation_endpoint: string;
}>;

declare function createRelyingParty(configurationFacade: ConfigurationFacadeOptions): {
    /**
     * Runs the validation of the configuration.
     */
    validateConfiguration(): Promise<void>;
    retrieveAvailableProviders(): Promise<Record<string, Array<{
        sub: string;
        organization_name: string;
        logo_uri?: string;
    }>>>;
    createEntityConfigurationResponse(): Promise<{
        status: number;
        headers: {
            "Content-Type": string;
        };
        body: string;
    }>;
    createAuthorizationRedirectURL(provider: string): Promise<string>;
    manageCallback(query: {
        code: string;
        state: string;
    } | {
        error: string;
        error_description?: string;
    }): Promise<{
        error: string;
        error_description?: string | undefined;
        type: "authentication-error";
        user_info?: undefined;
        tokens?: undefined;
    } | {
        type: "authentication-success";
        user_info: UserInfoCIE | UserInfoSPID;
        tokens: Readonly<{
            id_token: string;
            access_token: string;
            refresh_token?: string | undefined;
            revocation_endpoint: string;
        }>;
    }>;
    revokeTokens(tokens: Tokens): Promise<void>;
};

declare function generateJWKS(): Promise<{
    public_jwks: {
        keys: jose.JWK[];
    };
    private_jwks: {
        keys: jose.JWK[];
    };
}>;

declare function createLogRotatingFilesystem(options?: Pick<GeneralDailyRotateFileTransportOptions, "dirname">): AbstractLogging;

declare function createAuditLogRotatingFilesystem(options?: Pick<GeneralDailyRotateFileTransportOptions, "dirname">): (message: any) => void;

declare function createInMemoryAsyncStorage<T>(): AsyncStorage<T>;

declare const noopLogger: AbstractLogging;

declare const consoleLogger: AbstractLogging;

export { AcrValue, AsyncStorage, Configuration, Tokens, UserInfo, consoleLogger, createAuditLogRotatingFilesystem, createInMemoryAsyncStorage, createLogRotatingFilesystem, createRelyingParty, generateJWKS, noopLogger };
