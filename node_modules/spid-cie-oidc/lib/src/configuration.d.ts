import * as jose from "jose";
import { UserInfoCIE, UserInfoSPID } from "./requestUserInfo";
import { AuthenticationRequest } from "./createAuthenticationRequest";
/**
 * This configuration must be done on the relying party side
 *
 * see field descriptions to understand how to customize relying party
 */
export declare type Configuration = {
    /**
     * Url that identifies this relying party.
     * The relying party must be reachable on this url from outside
     */
    client_id: string;
    /**
     * Human-readable name of this application
     */
    client_name: string;
    /**
     * urls that identifies trust anchors
     *
     * @example ["https://registry.spid.gov.it/"]
     */
    trust_anchors: Array<string>;
    /**
     * OPTIONAL. JSON array with one or more strings representing contact persons at the entity.
     * These MAY contain names, e-mail addresses, descriptions, phone numbers, etc.
     *
     * See the [relevant specification for OpenID](https://openid.net/specs/openid-connect-federation-1_0.html#rfc.section.4.6).
     */
    contacts?: Array<string>;
    /**
     * urls that identifies identity providers
     * @example {
     *  spid: ["https://spid.ag-pub-full.it/"],
     *  cie: ["https://cie.agid.gov.it/"]
     * }
     */
    identity_providers: Record<IdentityProviderProfile, Array<string>>;
    /**
     * list of urls where the user browser will be redirected
     *
     * At least one redirect uri is required.
     *
     * The first redirect uri will be used for callback enpoint in this implementation
     *
     * @example ["https://my.domain/callback"]
     */
    redirect_uris: Array<string>;
    /**
     * you obtain these during onboarding process, they are needed for security purposes
     *
     * load them from filesystem or database
     */
    trust_marks: Array<TrustMark>;
    /**
     * jwks format of your public keys
     *
     * load them from filesystem or database (do not commit your cryprographic keys)
     *
     * these keys are needed during onboarding process wiht federation and for comunication with provider
     *
     * you can generate them with {@link generateJWKS}
     */
    public_jwks: JWKs;
    /** @see {@link Configuration.public_jwks} */
    private_jwks: JWKs;
    application_type: "web";
    response_types: Array<"code">;
    scope: Array<"openid" | "offline_access">;
    token_endpoint_auth_method: Array<"private_key_jwt">;
    providers: {
        [P in IdentityProviderProfile]: {
            /** what level of authentication is required */
            acr_values: AcrValue;
            /** what information to request about user from provider */
            requestedClaims: {
                id_token: Partial<Record<IdentityProviderProfileClaims[P], {
                    essential: true;
                }>>;
                userinfo: Partial<Record<IdentityProviderProfileClaims[P], null>>;
            };
        };
    };
    /** jwt default expiration in seconds */
    federation_default_exp: number;
    /** supply a storage that will be used to store intermediate stateful data  */
    storage: AsyncStorage<AuthenticationRequest>;
    /**
     * a function that will be called to log detailed events and exceptions
     * @see {@link logRotatingFilesystem} for an example
     */
    logger: AbstractLogging;
    /**
     * a function that will be called to log mandatory details that must be stored for 24 months (such as access_token, refresh_token, id_token)
     * @see {@link auditLogRotatingFilesystem} for an example
     */
    auditLogger(message: object | unknown): void;
    httpClient: HttpClient;
};
export declare type TrustMark = {
    id: string;
    trust_mark: string;
};
export declare type JWKs = {
    keys: Array<jose.JWK>;
};
declare type IdentityProviderProfile = "spid" | "cie";
declare type IdentityProviderProfileClaims = {
    spid: keyof UserInfoSPID;
    cie: keyof UserInfoCIE;
};
/** level of authentication */
export declare type AcrValue = typeof AcrValue[keyof typeof AcrValue];
/** level of authentication */
export declare const AcrValue: {
    readonly l1: "https://www.spid.gov.it/SpidL1";
    readonly l2: "https://www.spid.gov.it/SpidL2";
    readonly l3: "https://www.spid.gov.it/SpidL3";
};
declare type HttpRequest = {
    method: "GET";
    url: string;
    headers?: Record<string, string | undefined>;
} | {
    method: "POST";
    url: string;
    headers?: Record<string, string | undefined>;
    body: string;
};
declare type HttpResponse = {
    status: number;
    headers: Record<string, string | undefined>;
    body: string;
};
export declare type HttpClient = (request: HttpRequest) => Promise<HttpResponse>;
export declare type AsyncStorage<T> = {
    read(rowId: string): Promise<T>;
    write(rowId: string, value: T): Promise<void>;
    delete(rowId: string): Promise<void>;
};
export declare type LogLevels = "fatal" | "error" | "warn" | "info" | "debug" | "trace";
export declare type AbstractLogging = {
    [K in LogLevels]: (...args: any[]) => void;
};
declare type MandatoryConfiguration = Pick<Configuration, "client_id" | "client_name" | "trust_anchors" | "identity_providers" | "logger" | "auditLogger" | "storage">;
declare type AdditionalConfiguration = {
    /**
     * The path (relative to the CWD) where to find the Public JWKs, if not passed
     * directly as `public_jwks`.
     */
    public_jwks_path?: string;
    /**
     * The path (relative to the CWD) where to find the Private JWKs, if not passed
     * directly as `private_jwks`.
     */
    private_jwks_path?: string;
    /**
     * The path (relative to the CWD) where to find the Trust Marks, if not passed
     * directly as `trust_marks`.
     */
    trust_marks_path?: string;
};
export declare type ConfigurationFacadeOptions = MandatoryConfiguration & Partial<Configuration> & AdditionalConfiguration;
/**
 * This is a configuration facade to minimize setup effort.
 * @see {@link Configuration} fields for further customization
 */
export declare function createConfigurationFromConfigurationFacade({ client_id, client_name, trust_anchors, identity_providers, public_jwks, public_jwks_path, private_jwks, private_jwks_path, trust_marks, trust_marks_path, logger, auditLogger, httpClient, ...rest }: ConfigurationFacadeOptions): Promise<Configuration>;
export declare function validateConfiguration(configuration: Configuration): Promise<void>;
export {};
//# sourceMappingURL=configuration.d.ts.map