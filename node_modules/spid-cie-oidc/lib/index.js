'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jose = require('jose');
var crypto = require('crypto');
var fs = require('fs');
var uuid = require('uuid');
var undici = require('undici');
var Ajv = require('ajv');
var lodash = require('lodash');
var winston = require('winston');
require('winston-daily-rotate-file');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var jose__namespace = /*#__PURE__*/_interopNamespace(jose);
var crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);
var fs__namespace = /*#__PURE__*/_interopNamespace(fs);
var uuid__namespace = /*#__PURE__*/_interopNamespace(uuid);
var undici__namespace = /*#__PURE__*/_interopNamespace(undici);
var Ajv__default = /*#__PURE__*/_interopDefaultLegacy(Ajv);
var winston__namespace = /*#__PURE__*/_interopNamespace(winston);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function createJWS(payload, jwk) {
    return __awaiter(this, void 0, void 0, function* () {
        const privateKey = yield jose__namespace.importJWK(jwk, inferAlgForJWK(jwk));
        const jws = yield new jose__namespace.CompactSign(new TextEncoder().encode(JSON.stringify(payload)))
            .setProtectedHeader({ alg: "RS256", kid: jwk.kid })
            .sign(privateKey);
        return jws;
    });
}
function verifyJWS(jws, public_jwks) {
    return __awaiter(this, void 0, void 0, function* () {
        const { payload } = yield jose__namespace.compactVerify(jws, (header) => __awaiter(this, void 0, void 0, function* () {
            if (!header.kid)
                throw new Error("missing kid in header");
            const jwk = public_jwks.keys.find((key) => key.kid === header.kid);
            if (!jwk)
                throw new Error("no matching key with kid found");
            return yield jose__namespace.importJWK(jwk, inferAlgForJWK(jwk));
        }));
        return JSON.parse(new TextDecoder().decode(payload));
    });
}
// now timestamp in seconds
function makeIat() {
    return Math.floor(Date.now() / 1000);
}
// now + delta timestamp in seconds
function makeExp(deltaSeconds = 33 * 60) {
    return Math.floor(makeIat() + deltaSeconds);
}
function makeJti() {
    return uuid__namespace.v4();
}
function generateRandomString(length) {
    return crypto__default["default"].randomBytes(length).toString("hex");
}
// SHOULDDO implement
function getPrivateJWKforProvider(configuration) {
    return configuration.private_jwks.keys[0];
}
function inferAlgForJWK(jwk) {
    if (jwk.kty === "RSA")
        return "RS256";
    if (jwk.kty === "EC")
        return "ES256";
    // SHOULDDO support more types
    throw new Error("unsupported key type");
}
function generateJWKS() {
    return __awaiter(this, void 0, void 0, function* () {
        const { publicKey, privateKey } = yield jose__namespace.generateKeyPair("RS256");
        const publicJWK = yield jose__namespace.exportJWK(publicKey);
        const kid = yield jose__namespace.calculateJwkThumbprint(publicJWK);
        publicJWK.kid = kid;
        const privateJWK = yield jose__namespace.exportJWK(privateKey);
        privateJWK.kid = kid;
        return {
            public_jwks: { keys: [publicJWK] },
            private_jwks: { keys: [privateJWK] },
        };
    });
}
function isValidURL(url) {
    try {
        new URL(url);
        return true;
    }
    catch (error) {
        return false;
    }
}
function isString(value) {
    return typeof value === "string";
}
function isUndefined(value) {
    return value === undefined;
}
function readJSON(path) {
    return __awaiter(this, void 0, void 0, function* () {
        return JSON.parse(yield fs__namespace.promises.readFile(path, "utf8"));
    });
}
const undiciHttpClient = (_a) => __awaiter(void 0, void 0, void 0, function* () {
    var { url } = _a, params = __rest(_a, ["url"]);
    const response = yield undici__namespace.request(url, params);
    return {
        status: response.statusCode,
        headers: response.headers,
        body: yield response.body.text(),
    };
});
const ajv = new Ajv__default["default"]();

const consoleLogger = {
    fatal: console.error,
    error: console.error,
    warn: console.warn,
    debug: console.debug,
    info: console.info,
    trace: console.trace,
};

/** level of authentication */
const AcrValue = {
    l1: "https://www.spid.gov.it/SpidL1",
    l2: "https://www.spid.gov.it/SpidL2",
    l3: "https://www.spid.gov.it/SpidL3",
};
function defaultAuditLogger(message) {
    console.error("Missing audit logger.", message);
}
/**
 * This is a configuration facade to minimize setup effort.
 * @see {@link Configuration} fields for further customization
 */
function createConfigurationFromConfigurationFacade(_a) {
    var { client_id, client_name, trust_anchors, identity_providers, public_jwks, public_jwks_path, private_jwks, private_jwks_path, trust_marks, trust_marks_path, logger = consoleLogger, auditLogger = defaultAuditLogger, httpClient = undiciHttpClient } = _a, rest = __rest(_a, ["client_id", "client_name", "trust_anchors", "identity_providers", "public_jwks", "public_jwks_path", "private_jwks", "private_jwks_path", "trust_marks", "trust_marks_path", "logger", "auditLogger", "httpClient"]);
    return __awaiter(this, void 0, void 0, function* () {
        if (public_jwks != null && public_jwks_path != null) {
            throw new Error(`Cannot use both 'public_jwks' and 'public_jwks_path' in the configuration`);
        }
        else if (public_jwks_path != null) {
            public_jwks = yield readJSON(public_jwks_path);
        }
        if (public_jwks == null) {
            throw new Error(`You need to pass a 'public_jwk' or 'public_jwks_path' configuration`);
        }
        if (private_jwks != null && private_jwks_path != null) {
            throw new Error(`Cannot use both 'private_jwks' and 'private_jwks_path' in the configuration`);
        }
        else if (private_jwks_path != null) {
            private_jwks = yield readJSON(private_jwks_path);
        }
        if (private_jwks == null) {
            throw new Error(`You need to pass a 'private_jwk' or 'private_jwks_path' configuration`);
        }
        if ((public_jwks != null) !== (private_jwks != null)) {
            throw new Error(`You need to pass 'public_jwks' and 'private_jwks' together.`);
        }
        if (trust_marks != null && trust_marks_path != null) {
            throw new Error(`Cannot use both 'trust_marks' and 'trust_marks_path' in the configuration`);
        }
        else if (trust_marks_path != null) {
            try {
                trust_marks = yield readJSON(trust_marks_path);
            }
            catch (error) {
                if (error.code === "ENOENT") {
                    trust_marks = [];
                }
                else {
                    throw new Error(`Could not load trust_marks from ${trust_marks_path}: ${error}`);
                }
            }
        }
        else if (trust_marks == null) {
            trust_marks = [];
        }
        return Object.assign({ client_id,
            client_name,
            trust_anchors,
            identity_providers, application_type: "web", response_types: ["code"], scope: ["openid", "offline_access"], token_endpoint_auth_method: ["private_key_jwt"], providers: {
                spid: {
                    acr_values: AcrValue.l2,
                    requestedClaims: {
                        id_token: {
                            "https://attributes.spid.gov.it/familyName": { essential: true },
                            "https://attributes.spid.gov.it/email": { essential: true },
                        },
                        userinfo: {
                            "https://attributes.spid.gov.it/name": null,
                            "https://attributes.spid.gov.it/familyName": null,
                            "https://attributes.spid.gov.it/email": null,
                            "https://attributes.spid.gov.it/fiscalNumber": null,
                        },
                    },
                },
                cie: {
                    acr_values: AcrValue.l2,
                    requestedClaims: {
                        id_token: {
                            family_name: { essential: true },
                            email: { essential: true },
                        },
                        userinfo: {
                            given_name: null,
                            family_name: null,
                            email: null,
                        },
                    },
                },
            }, federation_default_exp: 48 * 60 * 60, public_jwks,
            private_jwks,
            trust_marks, redirect_uris: [client_id + "callback"], logger,
            auditLogger,
            httpClient }, rest);
    });
}
function validateConfiguration(configuration) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!isValidURL(configuration.client_id)) {
            throw new Error(`configuration: client_id must be a valid url ${configuration.client_id}`);
        }
        if (configuration.application_type !== "web") {
            throw new Error(`configuration: application_type must be "web"`);
        }
        if (!lodash.isEqual(configuration.response_types, ["code"])) {
            throw new Error(`configuration: response_types must be ["code"]`);
        }
        const supportedScope = ["openid", "offline_access"];
        const scopeDiff = lodash.difference(configuration.scope, supportedScope);
        if (scopeDiff.length > 0) {
            throw new Error(`configuration: scope must be subset of ${JSON.stringify(supportedScope)}`);
        }
        if (lodash.uniq(configuration.scope).length !== configuration.scope.length) {
            throw new Error(`configuration: scope must not contain duplicates ${JSON.stringify(configuration.scope)}`);
        }
        if (!lodash.isEqual(configuration.token_endpoint_auth_method, ["private_key_jwt"])) {
            throw new Error(`configuration: token_endpoint_auth_method must be ["private_key_jwt"]`);
        }
        if (configuration.federation_default_exp <= 0) {
            throw new Error(`configuration: federation_default_exp must be > 0`);
        }
        const invalidTrustAnchors = configuration.trust_anchors.filter((url) => !isValidURL(url));
        if (invalidTrustAnchors.length > 0) {
            throw new Error(`configuration: trust_anchors must be a list of valid urls ${JSON.stringify(invalidTrustAnchors)}`);
        }
        for (const providerType of ["cie", "spid"]) {
            const invalidProviders = configuration.identity_providers[providerType].filter((url) => !isValidURL(url) && url.endsWith("/"));
            if (invalidProviders.length > 0) {
                throw new Error(`configuration: identity_providers must be a list of valid urls ${JSON.stringify(invalidProviders)}`);
            }
        }
        if (configuration.redirect_uris.length < 1) {
            throw new Error(`configuration: redirect_uris must be at least one`);
        }
        const invalidRedirectUris = configuration.redirect_uris.filter((url) => !isValidURL(url));
        if (invalidRedirectUris.length > 0) {
            throw new Error(`configuration: redirect_uris must be a list of valid urls ${JSON.stringify(invalidRedirectUris)}`);
        }
        if (configuration.public_jwks.keys.length < 1) {
            throw new Error(`configuration: public_jwks must be at least one`);
        }
        if (configuration.private_jwks.keys.length !== configuration.public_jwks.keys.length) {
            throw new Error(`configuration: public_jwks and private_jwks must have the same length`);
        }
        for (const public_jwk of configuration.public_jwks.keys) {
            try {
                yield jose__namespace.importJWK(public_jwk, inferAlgForJWK(public_jwk));
            }
            catch (error) {
                throw new Error(`configuration: public_jwks must be a list of valid jwks ${JSON.stringify(public_jwk)}`);
            }
        }
        for (const private_jwk of configuration.private_jwks.keys) {
            try {
                yield jose__namespace.importJWK(private_jwk, inferAlgForJWK(private_jwk));
            }
            catch (error) {
                throw new Error(`configuration: private_jwks must be a list of valid jwks ${JSON.stringify(private_jwk)}`);
            }
        }
        for (const public_jwk of configuration.public_jwks.keys) {
            if (!public_jwk.kid) {
                throw new Error(`configuration: public_jwks must have a kid ${JSON.stringify(public_jwk)}`);
            }
            if (!configuration.private_jwks.keys.some((private_jwk) => private_jwk.kid === public_jwk.kid)) {
                throw new Error(`configuration: public_jwks and private_jwks must have mtching kid ${JSON.stringify(public_jwk)}`);
            }
        }
        if (typeof configuration.logger !== "object") {
            throw new Error(`configuration: logger must be an object conforming to the Abstract Logging interface`);
        }
        if (typeof configuration.auditLogger !== "function") {
            throw new Error(`configuration: auditLogger must be a function`);
        }
    });
}

function requestAccessToken(configuration, authenticationRequest, code) {
    return __awaiter(this, void 0, void 0, function* () {
        const request = {
            url: authenticationRequest.token_endpoint,
            method: "POST",
            headers: {
                "content-type": "application/x-www-form-urlencoded",
            },
            body: new URLSearchParams({
                grant_type: "authorization_code",
                redirect_uri: authenticationRequest.redirect_uri,
                client_id: configuration.client_id,
                state: authenticationRequest.state,
                code,
                code_verifier: authenticationRequest.code_verifier,
                client_assertion_type: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
                client_assertion: yield createJWS({
                    iss: configuration.client_id,
                    sub: configuration.client_id,
                    aud: [authenticationRequest.token_endpoint],
                    iat: makeIat(),
                    exp: makeExp(),
                    jti: makeJti(),
                }, getPrivateJWKforProvider(configuration)),
            }).toString(),
        };
        // SHOULDDO when doing post request ensure timeout and ssl is respected
        configuration.logger.info({ message: "Access token request", request });
        const response = yield configuration.httpClient(request);
        if (response.status === 200) {
            configuration.logger.info({ message: "Access token request succeeded", request, response });
            const tokens = JSON.parse(response.body);
            if (!isString(tokens.access_token) ||
                !isString(tokens.id_token) ||
                !(lodash.isUndefined(tokens.refresh_token) || isString(tokens.refresh_token))) {
                throw new Error(`Invalid response from token endpoint: ${response.body}`);
            }
            configuration.auditLogger(tokens);
            return tokens;
        }
        else {
            configuration.logger.error({ message: "Access token request failed", request, response });
            throw new Error(`access token request failed`);
        }
    });
}

// SHOULDDO implement arbitray length tst chain validation
// SHOULDDO check authority hints
function getAndVerifyTrustChain(configuration, relying_party, identity_provider, trust_anchor) {
    return __awaiter(this, void 0, void 0, function* () {
        const relying_party_entity_configuration = yield getEntityConfiguration(configuration, relying_party, validateRelyingPartyEntityConfiguration);
        const identity_provider_entity_configuration = yield getEntityConfiguration(configuration, identity_provider, validateIdentityProviderEntityConfiguration);
        const trust_anchor_entity_configuration = yield getEntityConfiguration(configuration, trust_anchor, validateTrustAnchorEntityConfiguration);
        const relying_party_entity_statement = yield getEntityStatement(configuration, relying_party_entity_configuration, trust_anchor_entity_configuration);
        const identity_provider_entity_statement = yield getEntityStatement(configuration, identity_provider_entity_configuration, trust_anchor_entity_configuration);
        const exp = Math.min(relying_party_entity_statement.exp, identity_provider_entity_statement.exp);
        const metadata = applyMetadataPolicy(identity_provider_entity_configuration.metadata, identity_provider_entity_statement.metadata_policy);
        const entity_configuration = Object.assign(Object.assign({}, identity_provider_entity_configuration), { metadata });
        configuration.logger.info({
            message: "Trust chain verified",
            relying_party,
            identity_provider,
            trust_anchor,
            relying_party_entity_configuration,
            identity_provider_entity_configuration,
            relying_party_entity_statement,
            identity_provider_entity_statement,
            exp,
            metadata,
        });
        return { exp, entity_configuration };
    });
}
function getEntityStatement(configuration, descendant, superior) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const response = yield configuration.httpClient({
                url: `${superior.metadata.federation_entity.federation_fetch_endpoint}?sub=${descendant.sub}`,
                method: "GET",
            });
            if (response.status !== 200) {
                throw new Error(`Expected status 200 but got ${response.status}`);
            }
            if (!((_a = response.headers["content-type"]) === null || _a === void 0 ? void 0 : _a.startsWith("application/entity-statement+jwt"))) {
                throw new Error(`Expected content-type application/entity-statement+jwt but got ${response.headers["content-type"]}`);
            }
            const jws = yield response.body;
            return yield verifyJWS(jws, superior.jwks);
        }
        catch (error) {
            throw new Error(`Failed to get entity statement for ${descendant.sub} from ${superior.metadata.federation_entity.federation_fetch_endpoint} beacuse of ${error}`);
        }
    });
}
function getEntityConfiguration(configuration, url, validateFunction) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        try {
            // SHOULDDO when doing post request ensure timeout and ssl is respected
            const response = yield configuration.httpClient({
                url: url + ".well-known/openid-federation",
                method: "GET",
            });
            const jws = yield response.body;
            if (response.status !== 200) {
                throw new Error(`Expected status 200 but got ${response.status}`);
            }
            if (!((_a = response.headers["content-type"]) === null || _a === void 0 ? void 0 : _a.startsWith("application/entity-statement+jwt"))) {
                throw new Error(`Expected content-type application/entity-statement+jwt but got ${response.headers["content-type"]}`);
            }
            const entity_configuration = yield verifyEntityConfiguration(jws);
            if (!validateFunction(entity_configuration)) {
                throw new Error(`Malformed entity configuration ${JSON.stringify(entity_configuration)} ${JSON.stringify(validateFunction.errors)}`);
            }
            return entity_configuration;
        }
        catch (error) {
            throw new Error(`Failed to get entity configuration for ${url} because of ${error}`);
        }
    });
}
function applyMetadataPolicy(metadata, policy) {
    var _a;
    metadata = lodash.cloneDeep(metadata);
    for (const [parentField, parentPolicy] of Object.entries(policy)) {
        if (!(parentField in metadata))
            continue;
        for (const [childField, childPolicy] of Object.entries(parentPolicy)) {
            if (childPolicy.add) {
                metadata[parentField][childField] = [...((_a = metadata[parentField][childField]) !== null && _a !== void 0 ? _a : []), childPolicy.add];
            }
            if (childPolicy.value) {
                metadata[parentField][childField] = childPolicy.value;
            }
            if (childPolicy.default) {
                if (!(childField in metadata[parentField])) {
                    metadata[parentField][childField] = childPolicy.value;
                }
            }
            if (childPolicy.subset_of) {
                if (lodash.intersection(metadata[parentField][childField], childPolicy.subset_of).length === 0) {
                    delete metadata[parentField][childField];
                }
            }
            if (childPolicy.superset_of) {
                if (lodash.difference(metadata[parentField][childField], childPolicy.superset_of).length === 0) {
                    delete metadata[parentField][childField];
                }
            }
            if (childPolicy.one_of) {
                if (!childPolicy.one_of.includes(metadata[parentField][childField])) {
                    delete metadata[parentField][childField];
                }
            }
        }
    }
    return metadata;
}
function verifyEntityConfiguration(jws) {
    return __awaiter(this, void 0, void 0, function* () {
        const decoded = jose__namespace.decodeJwt(jws);
        return yield verifyJWS(jws, decoded.jwks);
    });
}
const trustChainCache = new Map();
function CachedTrustChain(configuration, relying_party, identity_provider, trust_anchor) {
    return __awaiter(this, void 0, void 0, function* () {
        const cacheKey = `${relying_party}-${identity_provider}-${trust_anchor}`;
        const cached = trustChainCache.get(cacheKey);
        const now = makeIat();
        if (cached && cached.exp > now) {
            return cached;
        }
        else {
            const trust_chain = yield getAndVerifyTrustChain(configuration, relying_party, identity_provider, trust_anchor);
            trustChainCache.set(cacheKey, trust_chain);
            return trust_chain;
        }
    });
}
function getTrustChain(configuration, provider) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const identityProviderTrustChain = (_a = (yield Promise.all(configuration.trust_anchors.map((trust_anchor) => __awaiter(this, void 0, void 0, function* () {
            try {
                return yield CachedTrustChain(configuration, configuration.client_id, provider, trust_anchor);
            }
            catch (error) {
                configuration.logger.warn(error);
                return null;
            }
        })))).find((trust_chain) => trust_chain !== null)) !== null && _a !== void 0 ? _a : null;
        return identityProviderTrustChain;
    });
}
const jwksSchema = {
    type: "object",
    properties: {
        keys: {
            type: "array",
            items: {
                type: "object",
            },
        },
    },
    required: ["keys"],
};
const relyingPartyEntityConfigurationSchema = {
    type: "object",
    properties: {
        iss: { type: "string" },
        sub: { type: "string" },
        iat: { type: "number" },
        exp: { type: "number" },
        jwks: jwksSchema,
        trust_marks: { type: "array" },
        authority_hints: { type: "array", items: { type: "string" } },
        metadata: {
            type: "object",
            properties: {
                openid_relying_party: {
                    type: "object",
                    properties: {
                        client_name: { type: "string" },
                        client_id: { type: "string" },
                        application_type: { type: "string" },
                        contacts: { type: "array", items: { type: "string" }, nullable: true },
                        subject_type: { type: "string" },
                        jwks: jwksSchema,
                        grant_types: { type: "array", items: { type: "string" } },
                        response_types: { type: "array", items: { type: "string" } },
                        redirect_uris: { type: "array", items: { type: "string" } },
                        client_registration_types: { type: "array", items: { type: "string" } },
                    },
                    required: [
                        "client_name",
                        "client_id",
                        "application_type",
                        "subject_type",
                        "jwks",
                        "grant_types",
                        "response_types",
                        "redirect_uris",
                        "client_registration_types",
                    ],
                },
            },
            required: ["openid_relying_party"],
        },
    },
    required: ["iss", "sub", "iat", "exp", "jwks", "authority_hints", "metadata"],
};
const validateRelyingPartyEntityConfiguration = ajv.compile(relyingPartyEntityConfigurationSchema);
const IdentityProviderEntityConfigurationSchema = {
    type: "object",
    properties: {
        iss: { type: "string" },
        sub: { type: "string" },
        iat: { type: "number" },
        exp: { type: "number" },
        jwks: jwksSchema,
        trust_marks: { type: "array" },
        authority_hints: { type: "array", items: { type: "string" } },
        metadata: {
            type: "object",
            properties: {
                openid_provider: {
                    type: "object",
                },
            },
            required: ["openid_provider"],
        },
    },
    required: ["iss", "sub", "iat", "exp", "jwks", "authority_hints", "metadata"],
};
const validateIdentityProviderEntityConfiguration = ajv.compile(IdentityProviderEntityConfigurationSchema);
const trustAnchorEntityConfigurationSchema = {
    type: "object",
    properties: {
        iss: { type: "string" },
        sub: { type: "string" },
        iat: { type: "number" },
        exp: { type: "number" },
        jwks: jwksSchema,
        metadata: {
            type: "object",
            properties: {
                federation_entity: {
                    type: "object",
                    properties: {
                        name: { type: "string" },
                        homepage_uri: { type: "string" },
                        contacts: { type: "array", items: { type: "string" } },
                        federation_fetch_endpoint: { type: "string" },
                        federation_list_endpoint: { type: "string" },
                        federation_resolve_endpoint: { type: "string" },
                        federation_status_endpoint: { type: "string" },
                    },
                    required: [
                        "name",
                        "homepage_uri",
                        "federation_fetch_endpoint",
                        "federation_list_endpoint",
                        "federation_resolve_endpoint",
                        "federation_status_endpoint",
                    ],
                },
            },
            required: ["federation_entity"],
        },
        trust_marks_issuers: {
            type: "object",
            additionalProperties: {
                type: "array",
                items: { type: "string" },
            },
            required: [],
        },
        constraints: {
            type: "object",
            properties: {
                max_path_length: { type: "number" },
            },
            required: ["max_path_length"],
        },
    },
    required: ["constraints", "exp", "iat", "iss", "jwks", "metadata", "sub", "trust_marks_issuers"],
};
const validateTrustAnchorEntityConfiguration = ajv.compile(trustAnchorEntityConfigurationSchema);

function createAuthenticationRequest(configuration, provider) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        if (!isValidURL(provider)) {
            throw new Error(`provider is not a valid url ${provider}`);
        }
        if (!Object.values(configuration.identity_providers).some((providers) => providers.includes(provider))) {
            throw new Error(`provider is not supported ${provider}`);
        }
        const identityProviderTrustChain = yield getTrustChain(configuration, provider);
        if (!identityProviderTrustChain) {
            throw new Error(`Unable to find trust chain for identity provider ${provider}`);
        }
        const { authorization_endpoint, token_endpoint, userinfo_endpoint, revocation_endpoint, jwks: provider_jwks, } = identityProviderTrustChain.entity_configuration.metadata.openid_provider;
        const profile = (_a = Object.entries(configuration.identity_providers).find(([, providers]) => providers.includes(provider))) === null || _a === void 0 ? void 0 : _a[0];
        const scope = "openid";
        const redirect_uri = configuration.redirect_uris[0];
        const acr_values = configuration.providers[profile].acr_values;
        const prompt = "consent login";
        const endpoint = authorization_endpoint;
        const nonce = generateRandomString(32);
        const state = generateRandomString(32);
        const { code_verifier, code_challenge, code_challenge_method } = getPKCE();
        const response_type = configuration.response_types[0];
        const client_id = configuration.client_id;
        const iat = makeIat();
        const aud = [provider, authorization_endpoint];
        const claims = configuration.providers[profile].requestedClaims;
        const iss = client_id;
        const sub = client_id;
        const jwk = getPrivateJWKforProvider(configuration);
        const request = yield createJWS({
            scope,
            redirect_uri,
            response_type,
            nonce,
            state,
            client_id,
            endpoint,
            acr_values,
            iat,
            aud,
            claims,
            prompt,
            code_challenge,
            code_challenge_method,
            iss,
            sub,
        }, jwk);
        const url = `${authorization_endpoint}?${new URLSearchParams({
            scope,
            redirect_uri,
            nonce,
            state,
            response_type,
            client_id,
            endpoint,
            acr_values,
            iat: iat.toString(),
            aud: JSON.stringify(aud),
            claims: JSON.stringify(claims),
            code_challenge,
            code_challenge_method,
            prompt,
            request,
        })}`;
        yield configuration.storage.write(state, {
            state,
            code_verifier,
            redirect_uri,
            token_endpoint,
            userinfo_endpoint,
            revocation_endpoint,
            provider_jwks,
        });
        configuration.logger.info({ message: "Authentication request created", url });
        return url;
    });
}
// SHOULDDO support more code challange methods
function getPKCE() {
    const length = 64; // SHOULDDO read from config
    const code_verifier = generateRandomString(length);
    const code_challenge_method = "S256"; // SHOULDDO read from config
    const code_challenge = crypto__default["default"].createHash("sha256").update(code_verifier).digest("base64url");
    return {
        code_verifier,
        code_challenge,
        code_challenge_method,
    };
}

function createEntityConfiguration(configuration) {
    return __awaiter(this, void 0, void 0, function* () {
        const iat = makeIat();
        const exp = makeExp(configuration.federation_default_exp);
        const iss = configuration.client_id;
        const sub = configuration.client_id;
        const client_id = configuration.client_id;
        const authority_hints = configuration.trust_anchors;
        // SHOULDDO use separate keys for core and federation
        // use federation public jwks for federation related operations such as onboarding
        const jwks = configuration.public_jwks;
        const trust_marks = configuration.trust_marks;
        const client_name = configuration.client_name;
        const application_type = configuration.application_type;
        const contacts = configuration.contacts;
        const redirect_uris = configuration.redirect_uris;
        const response_types = configuration.response_types;
        const entity_configuration = {
            iat,
            exp,
            iss,
            sub,
            jwks,
            metadata: {
                openid_relying_party: {
                    application_type,
                    client_id,
                    client_registration_types: ["automatic"],
                    jwks,
                    client_name,
                    contacts,
                    grant_types: ["refresh_token", "authorization_code"],
                    redirect_uris,
                    response_types,
                    subject_type: "pairwise",
                },
            },
            trust_marks,
            authority_hints,
        };
        const jwk = configuration.private_jwks.keys[0]; // SHOULDDO make it configurable
        const jws = yield createJWS(entity_configuration, jwk);
        return jws;
    });
}

function revokeAccessToken(configuration, tokens) {
    return __awaiter(this, void 0, void 0, function* () {
        const request = {
            url: tokens.revocation_endpoint,
            method: "POST",
            headers: { "content-type": "application/x-www-form-urlencoded" },
            body: new URLSearchParams({
                token: tokens.access_token,
                client_id: configuration.client_id,
                client_assertion_type: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
                client_assertion: yield createJWS({
                    iss: configuration.client_id,
                    sub: configuration.client_id,
                    aud: [tokens.revocation_endpoint],
                    iat: makeIat(),
                    exp: makeExp(),
                    jti: makeJti(),
                }, getPrivateJWKforProvider(configuration)),
            }).toString(),
        };
        configuration.logger.info({ message: `Revocation request`, request });
        // SHOULDDO when doing post request ensure timeout and ssl is respected
        const response = yield configuration.httpClient(request);
        if (response.status === 200) {
            configuration.logger.info({ message: `Revocation request succeeded`, request, response });
        }
        else {
            configuration.logger.warn({ message: `Revocation request failed`, request, response });
        }
    });
}

function requestUserInfo(configuration, authenticationRequest, access_token) {
    return __awaiter(this, void 0, void 0, function* () {
        const request = {
            method: "GET",
            url: authenticationRequest.userinfo_endpoint,
            headers: { Authorization: `Bearer ${access_token}` },
        };
        configuration.logger.info({ message: "User info request", request });
        // SHOULDDO ensure timeout and ssl is respected
        const response = yield configuration.httpClient(request);
        if (response.status === 200 && response.headers["content-type"] === "application/jose") {
            const jwe = yield response.body;
            const jws = yield decrypt(configuration, jwe);
            const jwt = yield verify(authenticationRequest, jws);
            configuration.logger.info({ message: "User info request succeeded", request, response });
            if (!(validateUserInfoCie(jwt) || validateUserInfoSpid(jwt))) {
                throw new Error("invalid user info response");
            }
            return jwt;
        }
        else {
            configuration.logger.error({ message: "User info request failed", request, response });
            throw new Error(`User info request failed`);
        }
    });
}
function decrypt(configuration, jwe) {
    return __awaiter(this, void 0, void 0, function* () {
        const { plaintext } = yield jose__namespace.compactDecrypt(jwe, (header) => __awaiter(this, void 0, void 0, function* () {
            if (!header.kid)
                throw new Error("missing kid in header");
            const jwk = configuration.private_jwks.keys.find((key) => key.kid === header.kid);
            if (!jwk)
                throw new Error("no matching key with kid found");
            return yield jose__namespace.importJWK(jwk, inferAlgForJWK(jwk));
        }));
        return new TextDecoder().decode(plaintext);
    });
}
function verify(authenticationRequest, jws) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield verifyJWS(jws, authenticationRequest.provider_jwks);
        }
        catch (error) {
            if (error.code === "ERR_JWS_SIGNATURE_VERIFICATION_FAILED") {
                // user info jwt verificatrion failed, this should not happen
                // SHOULDDO file issue upstream
                return jose__namespace.decodeJwt(jws);
            }
            else {
                throw error;
            }
        }
    });
}
const userInfoCieSchema = {
    type: "object",
    properties: {
        sub: { type: "string", nullable: true },
        given_name: { type: "string", nullable: true },
        family_name: { type: "string", nullable: true },
        email: { type: "string", nullable: true },
        email_verified: { type: "string", nullable: true },
        gender: { type: "string", nullable: true },
        birthdate: { type: "string", nullable: true },
        phone_number: { type: "string", nullable: true },
        phone_number_verified: { type: "string", nullable: true },
        address: { type: "string", nullable: true },
        place_of_birth: { type: "string", nullable: true },
        document_details: { type: "string", nullable: true },
        e_delivery_service: { type: "string", nullable: true },
        fiscal_number: { type: "string", nullable: true },
        physical_phone_number: { type: "string", nullable: true },
    },
};
const validateUserInfoCie = ajv.compile(userInfoCieSchema);
const userInfoSpidSchema = {
    type: "object",
    properties: {
        "https://attributes.spid.gov.it/name": { type: "string", nullable: true },
        "https://attributes.spid.gov.it/familyName": { type: "string", nullable: true },
        "https://attributes.spid.gov.it/placeOfBirth": { type: "string", nullable: true },
        "https://attributes.spid.gov.it/countyOfBirth": { type: "string", nullable: true },
        "https://attributes.spid.gov.it/dateOfBirth": { type: "string", nullable: true },
        "https://attributes.spid.gov.it/gender": { type: "string", nullable: true },
        "https://attributes.spid.gov.it/companyName": { type: "string", nullable: true },
        "https://attributes.spid.gov.it/registeredOffice": { type: "string", nullable: true },
        "https://attributes.spid.gov.it/fiscalNumber": { type: "string", nullable: true },
        "https://attributes.spid.gov.it/ivaCode": { type: "string", nullable: true },
        "https://attributes.spid.gov.it/idCard": { type: "string", nullable: true },
        "https://attributes.spid.gov.it/mobilePhone": { type: "string", nullable: true },
        "https://attributes.spid.gov.it/email": { type: "string", nullable: true },
        "https://attributes.spid.gov.it/address": { type: "string", nullable: true },
        "https://attributes.spid.gov.it/expirationDate": { type: "string", nullable: true },
        "https://attributes.spid.gov.it/digitalAddress": { type: "string", nullable: true },
    },
};
const validateUserInfoSpid = ajv.compile(userInfoSpidSchema);

function createRelyingParty(configurationFacade) {
    let _configuration = null;
    function setupConfiguration() {
        return __awaiter(this, void 0, void 0, function* () {
            if (_configuration == null) {
                _configuration = yield createConfigurationFromConfigurationFacade(configurationFacade);
                yield validateConfiguration(_configuration);
            }
            return _configuration;
        });
    }
    return {
        /**
         * Runs the validation of the configuration.
         */
        validateConfiguration() {
            return __awaiter(this, void 0, void 0, function* () {
                yield setupConfiguration();
            });
        },
        retrieveAvailableProviders() {
            return __awaiter(this, void 0, void 0, function* () {
                const configuration = yield setupConfiguration();
                try {
                    const getProviderInfo = (provider) => __awaiter(this, void 0, void 0, function* () {
                        var _a, _b, _c, _d;
                        const trustChain = yield getTrustChain(configuration, provider);
                        if (!trustChain)
                            return null;
                        return {
                            sub: trustChain.entity_configuration.sub,
                            organization_name: (_b = (_a = trustChain.entity_configuration.metadata) === null || _a === void 0 ? void 0 : _a.openid_provider) === null || _b === void 0 ? void 0 : _b.organization_name,
                            logo_uri: (_d = (_c = trustChain.entity_configuration.metadata) === null || _c === void 0 ? void 0 : _c.openid_provider) === null || _d === void 0 ? void 0 : _d.logo_uri,
                        };
                    });
                    return Object.fromEntries(yield Promise.all(Object.entries(configuration.identity_providers).map(([providerProfile, providers]) => __awaiter(this, void 0, void 0, function* () {
                        return [providerProfile, (yield Promise.all(providers.map(getProviderInfo))).filter(Boolean)];
                    }))));
                }
                catch (error) {
                    configuration.logger.error(error);
                    throw error;
                }
            });
        },
        createEntityConfigurationResponse() {
            return __awaiter(this, void 0, void 0, function* () {
                const configuration = yield setupConfiguration();
                try {
                    const jws = yield createEntityConfiguration(configuration);
                    const response = {
                        status: 200,
                        headers: { "Content-Type": "application/entity-statement+jwt" },
                        body: jws,
                    };
                    return response;
                }
                catch (error) {
                    configuration.logger.error(error);
                    throw error;
                }
            });
        },
        createAuthorizationRedirectURL(provider) {
            return __awaiter(this, void 0, void 0, function* () {
                const configuration = yield setupConfiguration();
                try {
                    if (!isString(provider)) {
                        throw new Error("provider is mandatory parameter");
                    }
                    return yield createAuthenticationRequest(configuration, provider);
                }
                catch (error) {
                    configuration.logger.error(error);
                    throw error;
                }
            });
        },
        manageCallback(query) {
            return __awaiter(this, void 0, void 0, function* () {
                const configuration = yield setupConfiguration();
                configuration.logger.info({ message: "Callback function called", query });
                try {
                    if ("error" in query) {
                        if (!isString(query.error)) {
                            throw new Error("error is mandatory string parameter");
                        }
                        if (!(isString(query.error_description) || isUndefined(query.error_description))) {
                            throw new Error("error_description is optional string parameter");
                        }
                        configuration.logger.info({ message: "Callback function called with error", query });
                        return Object.assign({ type: "authentication-error" }, query);
                    }
                    else if ("code" in query) {
                        if (!isString(query.code)) {
                            throw new Error("code is mandatory string parameter");
                        }
                        if (!isString(query.state)) {
                            throw new Error("state is mandatory string parameter");
                        }
                        const authentication_request = yield configuration.storage.read(query.state);
                        if (!authentication_request) {
                            configuration.logger.warn({
                                message: "Callback function called with code but corresponding authentication with not found",
                                query,
                            });
                            throw new Error(`authentication request not found for state ${query.state}`);
                        }
                        const { id_token, access_token, refresh_token } = yield requestAccessToken(configuration, authentication_request, query.code);
                        const user_info = yield requestUserInfo(configuration, authentication_request, access_token);
                        const tokens = {
                            id_token,
                            access_token,
                            refresh_token,
                            revocation_endpoint: authentication_request.revocation_endpoint,
                        };
                        return { type: "authentication-success", user_info, tokens };
                    }
                    else {
                        throw new Error(`callback type not supported ${JSON.stringify(query)}`);
                    }
                }
                catch (error) {
                    configuration.logger.error(error);
                    throw error;
                }
            });
        },
        revokeTokens(tokens) {
            return __awaiter(this, void 0, void 0, function* () {
                const configuration = yield setupConfiguration();
                try {
                    return yield revokeAccessToken(configuration, tokens);
                }
                catch (error) {
                    configuration.logger.error(error);
                    throw error;
                }
            });
        },
    };
}

function createLogRotatingFilesystem(options) {
    const logger = winston__namespace.createLogger({
        format: winston__namespace.format.combine(winston__namespace.format.errors({ stack: true }), winston__namespace.format.metadata(), winston__namespace.format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }), winston__namespace.format.json()),
        transports: [
            new winston__namespace.transports.DailyRotateFile(Object.assign({ dirname: "logs", filename: "log-%DATE%.log", datePattern: "YYYY-MM-DD-HH", zippedArchive: true, maxSize: "20m" }, options)),
        ],
    });
    return {
        fatal: logger.error.bind(logger),
        error: logger.error.bind(logger),
        warn: logger.warn.bind(logger),
        debug: logger.debug.bind(logger),
        info: logger.info.bind(logger),
        trace: logger.debug.bind(logger),
    };
}

function createAuditLogRotatingFilesystem(options) {
    const logger = winston__namespace.createLogger({
        format: winston__namespace.format.combine(winston__namespace.format.metadata(), winston__namespace.format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }), winston__namespace.format.json()),
        transports: [
            new winston__namespace.transports.DailyRotateFile(Object.assign({ dirname: "logs", filename: "audit-%DATE%.log", datePattern: "YYYY-MM-DD-HH", zippedArchive: true, maxSize: "20m" }, options)),
        ],
    });
    return function auditLogRotatingFilesystem(message) {
        logger.info(message);
    };
}

function createInMemoryAsyncStorage() {
    const map = new Map();
    return {
        read(rowId) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!map.has(rowId))
                    throw new Error(`Key ${rowId} not found`);
                return map.get(rowId);
            });
        },
        write(rowId, value) {
            return __awaiter(this, void 0, void 0, function* () {
                map.set(rowId, value);
            });
        },
        delete(rowId) {
            return __awaiter(this, void 0, void 0, function* () {
                map.delete(rowId);
            });
        },
    };
}

function noop() { }
const noopLogger = {
    fatal: noop,
    error: noop,
    warn: noop,
    debug: noop,
    info: noop,
    trace: noop,
};

exports.AcrValue = AcrValue;
exports.consoleLogger = consoleLogger;
exports.createAuditLogRotatingFilesystem = createAuditLogRotatingFilesystem;
exports.createInMemoryAsyncStorage = createInMemoryAsyncStorage;
exports.createLogRotatingFilesystem = createLogRotatingFilesystem;
exports.createRelyingParty = createRelyingParty;
exports.generateJWKS = generateJWKS;
exports.noopLogger = noopLogger;
